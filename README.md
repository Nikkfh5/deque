# Deque (block-based deque<int>)
std::deque-like container for int: block-based ring buffer, O(1) push/pop both ends, O(1) indexing, stable references.

Реализация аналога `std::deque`, **только для `int`**.  
**Кольцевой буфер указателей на блоки фиксированного размера (512 байт)**. Блоки выделяются по мере необходимости и не перемещаются, поэтому адреса элементов остаются стабильными при росте структуры (кроме удаляемых элементов).

## Возможности

Реализован следующий интерфейс:

- `Deque()` - пустой дек
- `explicit Deque(std::size_t n)` - дек из `n` нулей
- `Deque(std::initializer_list<int>)` - `Deque d{1,2,3}`
- Конструкторы копирования/перемещения
- Оператор присваивания (copy-swap)
- `Swap(Deque&)`
- `PushBack(int)`, `PopBack()`
- `PushFront(int)`, `PopFront()`
- `int& operator[](std::size_t)` и `const int& operator[](std::size_t) const`
- `std::size_t Size() const`
- `Clear()`

## Идея реализации

- Дек хранит элементы в блоках `Block`, где `Block::buf` - массив `int` на **512 байт**:
  - элементов в блоке: `512 / sizeof(int)`
- Ссылки на блоки хранятся в массиве-**кольце** (ring buffer) из `std::unique_ptr<Block>`.
- Для вставок в начало/конец:
  - если в текущем головном/хвостовом блоке есть место - записываем туда
  - иначе выделяется новый блок слева/справа и добавляется в кольцевой буфер
- При нехватке места в кольцевом буфере он **увеличивается в 2 раза**. При этом:
  - **реаллоцируется только массив указателей на блоки**
  - сами блоки не перемещаются

## Гарантии и свойства

- `PushFront/PushBack/PopFront/PopBack` работают за O(1) (рост буфера указателей даёт амортизацию по числу блоков).
- Индексация `operator[]` - O(1): вычисляется номер блока и смещение внутри блока.
- Адреса элементов (ссылки/указатели на `int` внутри блоков) **не инвалидируются** при расширении структуры и при вставках/удалениях, кроме ссылок на удалённые элементы.

## Пример использования

```cpp
#include "deque.h"

int main() {
    Deque d{1, 2, 3};
    d.PushFront(0);
    d.PushBack(4);

    for (std::size_t i = 0; i < d.Size(); ++i) {
        (void)d[i];
    }
}
